<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>是男人就下100层</title>
  <meta name="theme-color" content="#000000" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  <meta name="apple-mobile-web-app-title" content="是男人就下100层" />
  <link rel="icon" href="logo.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="logo.png" />
  <link rel="manifest" href="manifest.json" />
  <style>
    :root {
      --c-bg: #000000;
      --c-fg: #ffffff;
      --c-dark: #303030;
      --c-mid: #707070;
      --c-light: #c0c0c0;
    }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: var(--c-bg);
      color: var(--c-fg);
      font-family: "Courier New", "Menlo", "Monaco", monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      overscroll-behavior: none;
      -webkit-text-size-adjust: none;
    }
    body {
      touch-action: none;
    }
    #wrap {
      width: 100%;
      min-height: 100dvh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      box-sizing: border-box;
    }
    #hud {
      width: min(680px, 96vw);
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 16px;
      letter-spacing: 0.5px;
      padding: 0 6px;
      box-sizing: border-box;
      gap: 10px;
      flex-wrap: wrap;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }
    #hp {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #hp-label {
      min-width: 90px;
    }
    #hp-bar {
      width: clamp(120px, 28vw, 180px);
      height: 12px;
      background: var(--c-dark);
      border: 1px solid var(--c-mid);
      box-sizing: border-box;
    }
    #hp-fill {
      height: 100%;
      width: 100%;
      background: var(--c-fg);
    }
    #mode-block {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    #difficulty {
      background: var(--c-bg);
      color: var(--c-fg);
      border: 1px solid var(--c-mid);
      padding: 2px 6px;
      font-size: 14px;
    }
    #hud-logo {
      width: clamp(36px, 8vw, 50px);
      height: clamp(36px, 8vw, 50px);
      object-fit: contain;
    }
    #game-box {
      border: 2px solid var(--c-mid);
      background: var(--c-bg);
      padding: 4px;
      max-width: 96vw;
      position: relative;
    }
    #start-btn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 8px 14px;
      font-size: 14px;
      letter-spacing: 1px;
      background: var(--c-bg);
      color: var(--c-fg);
      border: 1px solid var(--c-fg);
      cursor: pointer;
      z-index: 2;
    }
    #start-btn.hidden {
      display: none;
    }
    #game {
      touch-action: none;
    }
    #controls {
      width: min(680px, 96vw);
      display: flex;
      justify-content: space-between;
      padding: 0 10px 8px 10px;
      pointer-events: none;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      margin-top: 6px;
    }
    .ctrl-btn {
      pointer-events: auto;
      width: 78px;
      height: 78px;
      border-radius: 50%;
      background: var(--c-bg);
      border: 1px solid var(--c-fg);
      color: var(--c-fg);
      font-size: 22px;
      display: grid;
      place-items: center;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      touch-action: none;
      outline: none;
    }
    canvas {
      background: var(--c-bg);
      border: none;
      image-rendering: pixelated;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="hud">
      <div id="hp">
        <span id="hp-label">HP 15/15</span>
        <div id="hp-bar"><div id="hp-fill"></div></div>
      </div>
      <div id="mode-block">
        <label for="difficulty">MODE</label>
        <select id="difficulty">
          <option value="easy">E</option>
          <option value="normal" selected>N</option>
          <option value="hard">H</option>
        </select>
      </div>
      <div id="floor">地下: 0</div>
      <img id="hud-logo" src="logo.png?v=2" alt="Logo" />
    </div>
    <div id="game-box">
      <button id="start-btn" type="button">开始</button>
      <canvas id="game" width="480" height="640" aria-label="是男人就下100层"></canvas>
    </div>
    <div id="controls">
      <button class="ctrl-btn" id="btn-left" type="button">◀</button>
      <button class="ctrl-btn" id="btn-right" type="button">▶</button>
    </div>
  </div>

  <script>
    // Original name: NS-SHAFT (NAGI-P SOFT). UI uses the Chinese title only.
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const floorEl = document.getElementById("floor");
    const hpFillEl = document.getElementById("hp-fill");
    const hpLabelEl = document.getElementById("hp-label");
    const startBtn = document.getElementById("start-btn");
    const gameBox = document.getElementById("game-box");
    const btnLeft = document.getElementById("btn-left");
    const btnRight = document.getElementById("btn-right");
    const difficultyEl = document.getElementById("difficulty");

    const CONFIG = {
      title: "是男人就下100层",
      palette: {
        ink: {
          bg: "#000000",
          fg: "#ffffff",
          dark: "#303030",
          mid: "#707070",
          light: "#c0c0c0",
        },
        bw: {
          bg: "#000000",
          fg: "#ffffff",
          dark: "#000000",
          mid: "#ffffff",
          light: "#ffffff",
        },
        color: {
          bg: "#0b0d14",
          fg: "#f6f1e6",
          dark: "#1f2435",
          mid: "#6b7390",
          light: "#c0c0c0",
          normal: "#f2c14e",
          fragile: "#f08a5d",
          conveyor: "#4ecca3",
          spike: "#ff6b6b",
          spring: "#7bdcff",
        },
      },
      boot: {
        blackMs: 300,
        lineDelayMs: 240,
        titleBlinkCount: 2,
        titleBlinkIntervalMs: 220,
        promptBlinkMs: 400,
        lines: [
          "WQX System Booting...",
          "Memory Check: OK",
          "Input Device: Ready",
        ],
      },
      win: {
        floor: 100,
        holdMs: 3000,
      },
      tune: {
        maxLives: 15,
        damageSpike: 3,
        healNormal: 1,
        bottomDeathOffset: 80,
        gravityBase: 700,
        gravityAirAccel: 200,
        gravityAirAccelMax: 520,
        gravityLowBoost: 260,
        terminalVy: 1150,
        ceilingPushDown: 6,
        ceilingMinVy: 120,
        gapEasyAdjust: -8,
        gapHardAdjust: 10,
        scrollSpeeds: { easy: 50, normal: 75, hard: 100 },
        conveyorSpeeds: { easy: 55, normal: 70, hard: 80 },
        invuln: { easy: 1.5, normal: 1.3, hard: 1.1 },
      spikeSpeeds: { easy: 0, normal: 0, hard: 0 },
      },
    };

    const WORLD = {
      width: 360,
      height: 560,
    };

    const state = {
      mode: "boot",
      difficulty: "normal",
      displayMode: loadSetting("wqx-display", "ink"),
      bwMode: loadSetting("wqx-bw", "0") === "1",
      time: 0,
      clock: 0,
      bootStartMs: performance.now(),
      bootReady: false,
      winTimer: 0,
      floor: 0,
      lives: CONFIG.tune.maxLives,
      maxLives: CONFIG.tune.maxLives,
      cameraY: 0,
      scrollOffset: 0,
      spikeCeilingY: 0,
      spikeOffset: -10,
      spikeSpeed: CONFIG.tune.spikeSpeeds.normal,
      invuln: 0,
      invulnDuration: CONFIG.tune.invuln.normal,
      conveyorSpeed: CONFIG.tune.conveyorSpeeds.normal,
      scrollSpeed: CONFIG.tune.scrollSpeeds.normal,
      platforms: [],
      nextPlatformY: 0,
      airTime: 0,
      wasGrounded: false,
      keys: new Set(),
      sfx: null,
      player: {
        x: 160,
        y: 80,
        w: 26,
        h: 36,
        vx: 0,
        vy: 0,
        speed: 160,
        airControl: 0.8,
      },
    };

    applyPalette();
    ctx.imageSmoothingEnabled = false;

    function resize() {
      const padding = 20;
      const hudReserve = 72;
      const maxW = Math.max(320, window.innerWidth - padding * 2);
      const maxH = Math.max(320, window.innerHeight - padding * 2 - hudReserve);
      const ratio = WORLD.width / WORLD.height;
      let w = maxW;
      let h = Math.round(maxW / ratio);
      if (h > maxH) {
        h = maxH;
        w = Math.round(maxH * ratio);
      }
      canvas.width = w;
      canvas.height = h;
    }

    window.addEventListener("resize", resize);
    resize();

    function loadSetting(key, fallback) {
      try {
        const value = localStorage.getItem(key);
        return value === null ? fallback : value;
      } catch (err) {
        return fallback;
      }
    }

    function saveSetting(key, value) {
      try {
        localStorage.setItem(key, value);
      } catch (err) {
        // ignore
      }
    }

    function getPalette() {
      if (state.bwMode) return CONFIG.palette.bw;
      if (state.displayMode === "color") return CONFIG.palette.color;
      return CONFIG.palette.ink;
    }

    function applyPalette() {
      const pal = getPalette();
      document.documentElement.style.setProperty("--c-bg", pal.bg);
      document.documentElement.style.setProperty("--c-fg", pal.fg);
      document.documentElement.style.setProperty("--c-dark", pal.dark);
      document.documentElement.style.setProperty("--c-mid", pal.mid);
      document.documentElement.style.setProperty("--c-light", pal.light);
    }

    function toggleDisplayMode() {
      state.displayMode = state.displayMode === "color" ? "ink" : "color";
      saveSetting("wqx-display", state.displayMode);
      applyPalette();
    }

    function toggleBwMode() {
      state.bwMode = !state.bwMode;
      saveSetting("wqx-bw", state.bwMode ? "1" : "0");
      applyPalette();
    }

    function updateDifficulty() {
      if (state.difficulty === "easy") {
        state.scrollSpeed = CONFIG.tune.scrollSpeeds.easy;
        state.conveyorSpeed = CONFIG.tune.conveyorSpeeds.easy;
        state.invulnDuration = CONFIG.tune.invuln.easy;
        state.spikeSpeed = CONFIG.tune.spikeSpeeds.easy;
      } else if (state.difficulty === "hard") {
        state.scrollSpeed = CONFIG.tune.scrollSpeeds.hard;
        state.conveyorSpeed = CONFIG.tune.conveyorSpeeds.hard;
        state.invulnDuration = CONFIG.tune.invuln.hard;
        state.spikeSpeed = CONFIG.tune.spikeSpeeds.hard;
      } else {
        state.scrollSpeed = CONFIG.tune.scrollSpeeds.normal;
        state.conveyorSpeed = CONFIG.tune.conveyorSpeeds.normal;
        state.invulnDuration = CONFIG.tune.invuln.normal;
        state.spikeSpeed = CONFIG.tune.spikeSpeeds.normal;
      }
    }

    function resetGame() {
      state.time = 0;
      state.floor = 0;
      state.lives = state.maxLives;
      state.invuln = 0;
      state.cameraY = 0;
      state.scrollOffset = 0;
      state.spikeOffset = -10;
      state.spikeCeilingY = state.cameraY + state.spikeOffset;
      state.player.x = WORLD.width * 0.5 - state.player.w / 2;
      state.player.y = 60;
      state.player.vx = 0;
      state.player.vy = 40;
      state.platforms = [];
      state.nextPlatformY = 120;
      state.airTime = 0;
      state.wasGrounded = false;
      seedPlatforms();
      updateDifficulty();
      updateHud();
    }

    function seedPlatforms() {
      while (state.nextPlatformY < state.cameraY + WORLD.height + 800) {
        spawnPlatform(state.nextPlatformY);
        state.nextPlatformY += nextGap(state.nextPlatformY);
      }
    }

    function randRange(min, max) {
      return min + Math.random() * (max - min);
    }

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function nextGap(y) {
      const depth = Math.max(0, Math.floor((y - 60) / 120));
      let base = depth < 4 ? randRange(70, 100) : randRange(80, 115);
      if (state.difficulty === "easy") base += CONFIG.tune.gapEasyAdjust;
      if (state.difficulty === "hard") base += CONFIG.tune.gapHardAdjust;
      const bonus = Math.min(18, depth * 1.2);
      return base + bonus;
    }

    function choosePlatformType(depth) {
      const roll = Math.random();
      const hard = state.difficulty === "hard";
      const easy = state.difficulty === "easy";
      if (depth < 2) {
        return roll < (easy ? 0.85 : 0.75) ? "normal" : "fragile";
      }
      if (depth < 6) {
        if (roll < (easy ? 0.7 : hard ? 0.5 : 0.6)) return "normal";
        if (roll < (easy ? 0.86 : hard ? 0.74 : 0.78)) return "fragile";
        if (roll < (easy ? 0.94 : hard ? 0.88 : 0.9)) return "conveyor";
        if (roll < (easy ? 0.98 : hard ? 0.93 : 0.96)) return "spring";
        return "spike";
      }
      if (roll < (easy ? 0.65 : hard ? 0.45 : 0.55)) return "normal";
      if (roll < (easy ? 0.82 : hard ? 0.7 : 0.74)) return "fragile";
      if (roll < (easy ? 0.92 : hard ? 0.85 : 0.88)) return "conveyor";
      if (roll < (easy ? 0.97 : hard ? 0.91 : 0.95)) return "spring";
      return "spike";
    }

    function spawnPlatform(y) {
      const depth = Math.max(0, Math.floor((y - 60) / 120));
      let type = choosePlatformType(depth);
      if (depth < 2 && (type === "spike" || type === "conveyor" || type === "spring")) {
        type = "normal";
      }

      let width = randRange(100, 140);
      if (type === "fragile") width = randRange(80, 120);
      if (type === "conveyor") width = randRange(90, 130);
      if (type === "spike") width = randRange(90, 120);
      if (type === "spring") width = randRange(80, 110);

      const margin = 18;
      const minX = margin;
      const maxX = WORLD.width - width - margin;
      let x = clamp(randRange(minX, maxX), minX, maxX);

      const platform = {
        x,
        y,
        w: width,
        h: 12,
        type,
        used: false,
        breaking: false,
        breakTimer: 0,
        fallV: 0,
        conveyor: type === "conveyor" ? (Math.random() > 0.5 ? 1 : -1) : 0,
        springPower: type === "spring" ? randRange(320, 380) : 0,
      };
      state.platforms.push(platform);
    }

    function applyInput(dt, grounded) {
      const left = state.keys.has("ArrowLeft") || state.keys.has("KeyA");
      const right = state.keys.has("ArrowRight") || state.keys.has("KeyD");
      let dir = 0;
      if (left) dir -= 1;
      if (right) dir += 1;

      const control = grounded ? 1 : state.player.airControl;
      const target = dir * state.player.speed;
      state.player.vx = lerp(state.player.vx, target, 0.18 * control);
    }

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function update(dt) {
      state.time += dt;

      if (state.mode !== "playing") return;

      state.scrollOffset += state.scrollSpeed * dt;
      state.cameraY = state.scrollOffset;

      state.airTime += dt;
      let gravity = CONFIG.tune.gravityBase + Math.min(CONFIG.tune.gravityAirAccelMax, state.airTime * CONFIG.tune.gravityAirAccel);
      if (state.player.vy > 0 && state.player.y > state.cameraY + WORLD.height * 0.6) {
        gravity += CONFIG.tune.gravityLowBoost;
      }
      state.player.vy += gravity * dt;
      if (state.player.vy > CONFIG.tune.terminalVy) state.player.vy = CONFIG.tune.terminalVy;

      const wasY = state.player.y;
      const wasX = state.player.x;

      state.player.x += state.player.vx * dt;
      state.player.y += state.player.vy * dt;

      if (state.player.x < 0) {
        state.player.x = 0;
        state.player.vx = Math.max(0, state.player.vx);
      }
      if (state.player.x + state.player.w > WORLD.width) {
        state.player.x = WORLD.width - state.player.w;
        state.player.vx = Math.min(0, state.player.vx);
      }

      let grounded = false;
      let landedNormal = false;
      for (const p of state.platforms) {
        if ((p.used && p.type === "fragile") || p.breaking) continue;
        if (state.player.vy < 0 &&
            state.player.x + state.player.w > p.x &&
            state.player.x < p.x + p.w &&
            wasY >= p.y + p.h &&
            state.player.y <= p.y + p.h) {
          state.player.y = p.y + p.h;
          state.player.vy = 0;
          break;
        }
        if (state.player.vy >= 0 &&
            state.player.x + state.player.w > p.x &&
            state.player.x < p.x + p.w &&
            wasY + state.player.h <= p.y &&
            state.player.y + state.player.h >= p.y &&
            state.player.y < p.y + p.h) {
          if (p.type === "spike") {
            hurtPlayer();
            state.player.vy = -120;
            break;
          }
          if (p.type === "spring") {
            state.player.y = p.y - state.player.h;
            state.player.vy = -p.springPower;
            playSfx("spring");
            grounded = false;
            break;
          }
          grounded = true;
          landedNormal = p.type === "normal";
          state.player.y = p.y - state.player.h;
          state.player.vy = 0;
          state.airTime = 0;
          if (p.type === "fragile") {
            p.used = true;
            p.breaking = true;
            p.breakTimer = 0.18;
          }
          if (p.type === "conveyor") {
            const belt = p.conveyor * state.conveyorSpeed;
            const nearLeft = state.player.x <= 2 && belt < 0;
            const nearRight = state.player.x + state.player.w >= WORLD.width - 2 && belt > 0;
            if (!nearLeft && !nearRight) {
              state.player.x += belt * dt;
              state.player.vx += belt * 0.15;
            } else {
              state.player.vx *= 0.2;
            }
          }
          break;
        }
      }

      const justLanded = grounded && !state.wasGrounded;
      if (justLanded && landedNormal && state.lives < state.maxLives) {
        state.lives = Math.min(state.maxLives, state.lives + CONFIG.tune.healNormal);
      }

      // Side collision to prevent sliding into wall gaps at platform edges.
      for (const p of state.platforms) {
        if ((p.used && p.type === "fragile") || p.breaking) continue;
        const overlapY = state.player.y + state.player.h > p.y && state.player.y < p.y + p.h;
        if (!overlapY) continue;
        if (state.player.vx > 0 &&
            wasX + state.player.w <= p.x &&
            state.player.x + state.player.w >= p.x) {
          state.player.x = p.x - state.player.w;
          state.player.vx = 0;
        } else if (state.player.vx < 0 &&
                   wasX >= p.x + p.w &&
                   state.player.x <= p.x + p.w) {
          state.player.x = p.x + p.w;
          state.player.vx = 0;
        }
      }

      applyInput(dt, grounded);

      state.spikeOffset += state.spikeSpeed * dt;
      state.spikeCeilingY = state.cameraY + state.spikeOffset;
      const ceilingBottom = state.spikeCeilingY + 26;
      if (state.player.y <= ceilingBottom) {
        hurtPlayer();
        state.player.y = ceilingBottom + CONFIG.tune.ceilingPushDown;
        state.player.vy = Math.max(CONFIG.tune.ceilingMinVy, state.player.vy);
      }

      if (state.invuln > 0) {
        state.invuln -= dt;
        if (state.invuln < 0) state.invuln = 0;
      }

      const depth = Math.max(0, state.player.y - 60);
      state.floor = Math.floor(depth / 120);

      if (state.floor >= CONFIG.win.floor) {
        state.mode = "win";
        state.winTimer = 0;
      }

      const spawnAnchor = Math.max(state.cameraY, state.player.y);
      while (state.nextPlatformY < spawnAnchor + WORLD.height + 800) {
        spawnPlatform(state.nextPlatformY);
        state.nextPlatformY += nextGap(state.nextPlatformY);
      }

      for (const p of state.platforms) {
        if (p.breaking) {
          p.breakTimer -= dt;
          if (p.breakTimer <= 0) {
            p.breaking = false;
            p.fallV = 60;
          }
        }
        if (p.fallV > 0) {
          p.y += p.fallV * dt;
          p.fallV += 680 * dt;
        }
      }

      const keepMin = Math.min(state.cameraY, state.player.y) - 240;
      const keepMax = Math.max(state.cameraY, state.player.y) + WORLD.height + 800;
      state.platforms = state.platforms.filter(p => p.y > keepMin && p.y < keepMax);

      if (state.player.y > state.cameraY + WORLD.height + CONFIG.tune.bottomDeathOffset) {
        state.lives = 0;
        state.mode = "gameover";
        playSfx("gameover");
      }

      state.wasGrounded = grounded;
    }

    function updateWin(dt) {
      state.winTimer += dt * 1000;
      if (state.winTimer >= CONFIG.win.holdMs) {
        state.mode = "title";
      }
    }

    function hurtPlayer() {
      if (state.invuln > 0) return;
      state.lives -= CONFIG.tune.damageSpike;
      if (state.lives < 0) state.lives = 0;
      state.invuln = state.invulnDuration;
      playSfx("hurt");
      if (state.lives <= 0) {
        state.mode = "gameover";
        playSfx("gameover");
      }
    }

    function drawBackground() {
      const pal = getPalette();
      ctx.fillStyle = pal.bg;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Dot matrix grid
      ctx.fillStyle = pal.dark;
      for (let y = 0; y < canvas.height; y += 8) {
        for (let x = 0; x < canvas.width; x += 8) {
          ctx.fillRect(x, y, 1, 1);
        }
      }
    }

    function drawBoot() {
      const pal = getPalette();
      ctx.fillStyle = pal.bg;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const now = performance.now();
      const elapsed = now - state.bootStartMs;
      if (elapsed < CONFIG.boot.blackMs) return;

      const lineStart = CONFIG.boot.blackMs;
      const linesShown = Math.min(
        CONFIG.boot.lines.length,
        Math.floor((elapsed - lineStart) / CONFIG.boot.lineDelayMs) + 1
      );

      ctx.fillStyle = pal.fg;
      ctx.font = "16px \"Courier New\", monospace";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      let y = canvas.height * 0.25;
      for (let i = 0; i < linesShown; i++) {
        ctx.fillText(CONFIG.boot.lines[i], canvas.width * 0.12, y);
        y += 22;
      }

      const titleStart = lineStart + CONFIG.boot.lines.length * CONFIG.boot.lineDelayMs + 120;
      const titleBlinkTotal = CONFIG.boot.titleBlinkCount * 2;
      const titlePhase = Math.floor((elapsed - titleStart) / CONFIG.boot.titleBlinkIntervalMs);
      const titleVisible = elapsed >= titleStart && titlePhase < titleBlinkTotal ? titlePhase % 2 === 0 : elapsed >= titleStart + titleBlinkTotal * CONFIG.boot.titleBlinkIntervalMs;

      if (titleVisible) {
        ctx.textAlign = "center";
        ctx.font = "18px \"Courier New\", monospace";
        ctx.fillText(CONFIG.title, canvas.width / 2, canvas.height * 0.5);
      }

      const promptStart = titleStart + titleBlinkTotal * CONFIG.boot.titleBlinkIntervalMs + 200;
      if (elapsed >= promptStart) {
        const blink = Math.floor((elapsed - promptStart) / CONFIG.boot.promptBlinkMs) % 2 === 0;
        if (blink) {
          ctx.font = "14px \"Courier New\", monospace";
          ctx.fillText("Press Any Key", canvas.width / 2, canvas.height * 0.62);
        }
        state.bootReady = true;
      }
    }

    function drawCeiling(pal) {
      const ceilingY = state.spikeCeilingY - state.cameraY;
      ctx.fillStyle = pal.dark;
      ctx.fillRect(0, ceilingY, WORLD.width, 10);
      ctx.fillStyle = pal.fg;
      for (let i = 0; i < WORLD.width; i += 16) {
        ctx.beginPath();
        ctx.moveTo(i, ceilingY + 10);
        ctx.lineTo(i + 8, ceilingY + 26);
        ctx.lineTo(i + 16, ceilingY + 10);
        ctx.closePath();
        ctx.fill();
      }
    }

    function drawPlatform(p, pal) {
      const y = p.y - state.cameraY;
      ctx.strokeStyle = pal.mid;
      ctx.lineWidth = 1;

      if (p.type === "normal") {
        ctx.fillStyle = pal.light;
        ctx.fillRect(p.x, y, p.w, p.h);
        ctx.strokeRect(p.x, y, p.w, p.h);
      } else if (p.type === "fragile") {
        ctx.fillStyle = pal.light;
        ctx.fillRect(p.x, y, p.w, p.h);
        ctx.strokeRect(p.x, y, p.w, p.h);
        ctx.strokeStyle = pal.dark;
        // aligned hatch marks for fragile platforms
        for (let i = 2; i < p.w; i += 6) {
          ctx.beginPath();
          ctx.moveTo(p.x + i, y + 2);
          ctx.lineTo(p.x + i, y + p.h - 2);
          ctx.stroke();
        }
      } else if (p.type === "conveyor") {
        ctx.fillStyle = pal.mid;
        ctx.fillRect(p.x, y, p.w, p.h);
        ctx.strokeRect(p.x, y, p.w, p.h);
        ctx.strokeStyle = pal.fg;
        for (let i = 6; i < p.w - 6; i += 14) {
          ctx.beginPath();
          if (p.conveyor > 0) {
            ctx.moveTo(p.x + i, y + 4);
            ctx.lineTo(p.x + i + 6, y + 6);
            ctx.lineTo(p.x + i, y + 8);
          } else {
            ctx.moveTo(p.x + i + 6, y + 4);
            ctx.lineTo(p.x + i, y + 6);
            ctx.lineTo(p.x + i + 6, y + 8);
          }
          ctx.stroke();
        }
      } else if (p.type === "spike") {
        ctx.fillStyle = pal.dark;
        ctx.fillRect(p.x, y, p.w, p.h);
        ctx.strokeRect(p.x, y, p.w, p.h);
        ctx.fillStyle = pal.fg;
        const spikeHeight = 6;
        const step = 12;
        for (let i = 0; i <= p.w; i += step) {
          const x0 = p.x + i;
          const x1 = Math.min(p.x + i + step / 2, p.x + p.w);
          const x2 = Math.min(p.x + i + step, p.x + p.w);
          ctx.beginPath();
          ctx.moveTo(x0, y);
          ctx.lineTo(x1, y - spikeHeight);
          ctx.lineTo(x2, y);
          ctx.closePath();
          ctx.fill();
        }
      } else if (p.type === "spring") {
        const plateH = 3;
        ctx.fillStyle = pal.light;
        ctx.fillRect(p.x, y, p.w, plateH);
        ctx.strokeRect(p.x, y, p.w, plateH);
        ctx.fillRect(p.x, y + p.h - plateH, p.w, plateH);
        ctx.strokeRect(p.x, y + p.h - plateH, p.w, plateH);
        ctx.strokeStyle = pal.dark;
        const coilTop = y + plateH;
        const coilBottom = y + p.h - plateH;
        const coilW = p.w * 0.6;
        const coilX = p.x + (p.w - coilW) / 2;
        const segments = 5;
        for (let i = 0; i < segments; i++) {
          const t0 = i / segments;
          const t1 = (i + 1) / segments;
          const x0 = coilX + (i % 2 === 0 ? 0 : coilW);
          const x1 = coilX + (i % 2 === 0 ? coilW : 0);
          const y0 = coilTop + (coilBottom - coilTop) * t0;
          const y1 = coilTop + (coilBottom - coilTop) * t1;
          ctx.beginPath();
          ctx.moveTo(x0, y0);
          ctx.lineTo(x1, y1);
          ctx.stroke();
        }
      }
    }

    function drawPlayerPixel(x, y, w, h, pal, invert) {
      const sprite = [
        "   ####   ",
        "  ######  ",
        "  ##..##  ",
        "  ######  ",
        "   ####   ",
        "  ######  ",
        " ######## ",
        "   ####   ",
        "  ######  ",
        "  ######  ",
        "  ##  ##  ",
        "  ##  ##  ",
      ];
      const cols = sprite[0].length;
      const rows = sprite.length;
      const px = w / cols;
      const py = h / rows;
      const mainColor = invert ? pal.dark : pal.fg;
      const accentColor = invert ? pal.bg : pal.light;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const ch = sprite[r][c];
          if (ch === " ") continue;
          ctx.fillStyle = ch === "." ? accentColor : mainColor;
          ctx.fillRect(x + c * px, y + r * py, Math.ceil(px), Math.ceil(py));
        }
      }
    }

    function drawGame() {
      drawBackground();

      const pal = getPalette();
      const scale = Math.min(canvas.width / WORLD.width, canvas.height / WORLD.height);
      const offsetX = (canvas.width - WORLD.width * scale) / 2;
      const offsetY = (canvas.height - WORLD.height * scale) / 2;

      ctx.save();
      ctx.translate(offsetX, offsetY);
      ctx.scale(scale, scale);

      ctx.fillStyle = pal.bg;
      ctx.fillRect(0, 0, WORLD.width, WORLD.height);

      drawCeiling(pal);

      for (const p of state.platforms) {
        if (p.used && p.type === "fragile" && p.fallV <= 0) continue;
        drawPlatform(p, pal);
      }

      const hurtFlash = state.invuln > 0 && Math.floor(state.clock * 12) % 2 === 0;
      drawPlayerPixel(state.player.x, state.player.y - state.cameraY, state.player.w, state.player.h, pal, hurtFlash);

      ctx.restore();
    }

    function drawTitle() {
      drawBackground();
      ctx.fillStyle = getPalette().fg;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = "18px \"Courier New\", monospace";
      ctx.fillText(CONFIG.title, canvas.width / 2, canvas.height * 0.4);
      ctx.font = "14px \"Courier New\", monospace";
      ctx.fillText("按开始 / 任意键", canvas.width / 2, canvas.height * 0.5);
    }

    function drawGameOver() {
      drawGame();
      ctx.fillStyle = getPalette().fg;
      ctx.textAlign = "center";
      ctx.font = "16px \"Courier New\", monospace";
      ctx.fillText("GAME OVER", canvas.width / 2, canvas.height * 0.3);
      ctx.fillText(`地下 ${state.floor} 层`, canvas.width / 2, canvas.height * 0.36);
    }

    function drawWin() {
      drawBackground();
      ctx.fillStyle = getPalette().fg;
      ctx.textAlign = "center";
      ctx.font = "16px \"Courier New\", monospace";
      ctx.fillText("You made it.", canvas.width / 2, canvas.height * 0.4);
      ctx.fillText("地下 100 层", canvas.width / 2, canvas.height * 0.46);
      ctx.fillText("下面，没有了。", canvas.width / 2, canvas.height * 0.52);
    }

    function draw() {
      if (state.mode === "boot") {
        drawBoot();
        return;
      }
      if (state.mode === "title") {
        drawTitle();
        return;
      }
      if (state.mode === "gameover") {
        drawGameOver();
        return;
      }
      if (state.mode === "win") {
        drawWin();
        return;
      }
      drawGame();
    }

    function updateHud() {
      if (floorEl) floorEl.textContent = `地下: ${state.floor}`;
      if (hpLabelEl) hpLabelEl.textContent = `HP ${state.lives}/${state.maxLives}`;
      if (hpFillEl) {
        const ratio = Math.max(0, Math.min(1, state.lives / state.maxLives));
        hpFillEl.style.width = `${Math.round(ratio * 100)}%`;
      }
      if (startBtn) {
        if (state.mode === "playing" || state.mode === "boot" || state.mode === "win") {
          startBtn.classList.add("hidden");
        } else {
          startBtn.classList.remove("hidden");
          startBtn.textContent = state.mode === "gameover" ? "再来一次" : "开始";
          startBtn.style.top = state.mode === "gameover" ? "62%" : "50%";
        }
      }
    }

    function ensureAudio() {
      if (state.sfx) return;
      try {
        state.sfx = new (window.AudioContext || window.webkitAudioContext)();
      } catch (err) {
        state.sfx = null;
      }
    }

    function playSfx(kind) {
      if (!state.sfx) return;
      const ctxAudio = state.sfx;
      const now = ctxAudio.currentTime;
      const osc = ctxAudio.createOscillator();
      const gain = ctxAudio.createGain();
      osc.type = "square";
      if (kind === "start") {
        osc.frequency.value = 440;
        gain.gain.setValueAtTime(0.06, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
        osc.start(now);
        osc.stop(now + 0.12);
      } else if (kind === "hurt") {
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(110, now + 0.2);
        gain.gain.setValueAtTime(0.08, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
      } else if (kind === "spring") {
        osc.frequency.setValueAtTime(520, now);
        osc.frequency.exponentialRampToValueAtTime(760, now + 0.12);
        gain.gain.setValueAtTime(0.06, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
        osc.start(now);
        osc.stop(now + 0.15);
      } else if (kind === "gameover") {
        osc.frequency.setValueAtTime(180, now);
        osc.frequency.exponentialRampToValueAtTime(90, now + 0.3);
        gain.gain.setValueAtTime(0.08, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
        osc.start(now);
        osc.stop(now + 0.35);
      }
      osc.connect(gain);
      gain.connect(ctxAudio.destination);
    }

    function enterTitle() {
      state.mode = "title";
      updateHud();
    }

    function startGame() {
      state.mode = "playing";
      resetGame();
      playSfx("start");
      updateHud();
    }

    document.addEventListener("keydown", (e) => {
      ensureAudio();
      if (e.code === "KeyM") {
        toggleDisplayMode();
        return;
      }
      if (state.mode === "boot") {
        if (state.bootReady) enterTitle();
        return;
      }
      if (state.mode === "title" && e.code === "Enter") {
        startGame();
        return;
      }
      if (state.mode === "gameover" && (e.code === "Enter" || e.code === "KeyR")) {
        startGame();
        return;
      }
      state.keys.add(e.code);
    });

    document.addEventListener("keyup", (e) => {
      state.keys.delete(e.code);
    });

    if (startBtn) {
      startBtn.addEventListener("click", () => {
        ensureAudio();
        if (state.mode === "title" || state.mode === "gameover") {
          startGame();
        }
      });
    }

    if (difficultyEl) {
      difficultyEl.addEventListener("change", () => {
        state.difficulty = difficultyEl.value;
        updateDifficulty();
      });
    }

    function setKey(code, down) {
      if (down) state.keys.add(code);
      else state.keys.delete(code);
    }

    if (btnLeft) {
      btnLeft.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        setKey("ArrowLeft", true);
      });
      btnLeft.addEventListener("pointerup", () => setKey("ArrowLeft", false));
      btnLeft.addEventListener("pointerleave", () => setKey("ArrowLeft", false));
    }

    if (btnRight) {
      btnRight.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        setKey("ArrowRight", true);
      });
      btnRight.addEventListener("pointerup", () => setKey("ArrowRight", false));
      btnRight.addEventListener("pointerleave", () => setKey("ArrowRight", false));
    }

    let swipeStartX = null;
    if (canvas) {
      canvas.addEventListener("touchstart", (e) => {
        if (e.touches.length > 0) {
          swipeStartX = e.touches[0].clientX;
        }
      }, { passive: true });
      canvas.addEventListener("touchmove", (e) => {
        if (swipeStartX == null || e.touches.length === 0) return;
        const dx = e.touches[0].clientX - swipeStartX;
        if (Math.abs(dx) < 8) return;
        if (dx > 0) {
          setKey("ArrowRight", true);
          setKey("ArrowLeft", false);
        } else {
          setKey("ArrowLeft", true);
          setKey("ArrowRight", false);
        }
      }, { passive: true });
      canvas.addEventListener("touchend", () => {
        swipeStartX = null;
        setKey("ArrowLeft", false);
        setKey("ArrowRight", false);
      }, { passive: true });
    }

    if (gameBox) {
      gameBox.addEventListener("touchmove", (e) => e.preventDefault(), { passive: false });
    }

    let bootHoldTimer = null;
    let bootHoldFired = false;
    if (gameBox) {
      gameBox.addEventListener("pointerdown", () => {
        if (state.mode !== "boot") return;
        bootHoldFired = false;
        bootHoldTimer = setTimeout(() => {
          bootHoldFired = true;
          toggleBwMode();
        }, 3000);
      });
      gameBox.addEventListener("pointerup", () => {
        if (bootHoldTimer) clearTimeout(bootHoldTimer);
        bootHoldTimer = null;
        if (state.mode === "boot" && state.bootReady && !bootHoldFired) {
          enterTitle();
        }
      });
      gameBox.addEventListener("pointerleave", () => {
        if (bootHoldTimer) clearTimeout(bootHoldTimer);
        bootHoldTimer = null;
      });
    }

    function step(dt) {
      state.clock += dt;
      if (state.mode === "playing") {
        update(dt);
      } else if (state.mode === "win") {
        updateWin(dt);
      }
      draw();
      updateHud();
    }

    function gameLoop(lastTime) {
      return function tick(ts) {
        const delta = (ts - lastTime) / 1000;
        lastTime = ts;
        if (!useExternalAdvance) {
          const dt = Math.min(0.033, delta);
          step(dt);
        }
        requestAnimationFrame(tick);
      };
    }

    let useExternalAdvance = false;
    window.advanceTime = (ms) => {
      useExternalAdvance = true;
      const steps = Math.max(1, Math.round(ms / (1000 / 60)));
      for (let i = 0; i < steps; i++) step(1 / 60);
    };

    function renderGameToText() {
      const payload = {
        coordinateSystem: "origin top-left, +x right, +y down",
        mode: state.mode,
        displayMode: state.displayMode,
        bwMode: state.bwMode,
        difficulty: state.difficulty,
        player: {
          x: round(state.player.x),
          y: round(state.player.y),
          w: state.player.w,
          h: state.player.h,
          vx: round(state.player.vx),
          vy: round(state.player.vy),
        },
        lives: state.lives,
        floor: state.floor,
        spikeCeilingY: round(state.spikeCeilingY),
        cameraY: round(state.cameraY),
        platforms: state.platforms.map(p => ({
          x: round(p.x),
          y: round(p.y),
          w: round(p.w),
          h: p.h,
          type: p.type,
          conveyor: p.conveyor,
          falling: p.fallV > 0,
        })),
      };
      return JSON.stringify(payload);
    }
    window.render_game_to_text = renderGameToText;

    function round(n) {
      return Math.round(n * 10) / 10;
    }

    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("service-worker.js").catch(() => {});
    }

    updateDifficulty();
    updateHud();
    requestAnimationFrame(gameLoop(performance.now()));
  </script>
</body>
</html>
